**Абстракция** - это когда мы сосредотачиваемся только на существенных для задачи деталях и игнорируем всё остальное. В ООП абстракция означает, что для каждого объекта мы задаём минимальное количество методов, полей и описаний, которые позволят нам решить задачу. Чем меньше характеристик, тем лучше абстракция, но ключевые характеристики убирать нельзя.

**Наследование** - позволяет как бы вынести «за скобки» общее для разных классов. То есть, благодаря механизму наследования классов, мы можем использовать ранее созданные классы и расширять их функциональность.

**Инкапсуляция** -  объединение и скрытие методов и свойств, и предоставление доступа к ним через простой внешний интерфейс. Класс вообще должен восприниматься как единая, целостная конструкция, все внутренние манипуляции с его данными должны быть сокрыты в этом классе и в идеале недоступны извне. То есть, к скрытым данным и методам нельзя напрямую обращаться извне, только внутри класса. 

**Полиморфизм** - благодаря параметрическому полиморфизму, мы можем оперировать разными типами объектов через их единый базовый класс


`__del__` - финализатор (удаление) объекта класса (автоматически вызывается перед уничтожением экземпляра класса)

`__new__` - вызывает создание объекта класса
```Python
class Point:
	def __new__(cls, *args, **kwargs):
		print("вызов __new__ для " + str(cls))
		# return super().__new__(cls) без этой строчки, объект класса не создастся

	def __init__(self, x=0, y=0):
		print("вызов __init__ для " + str(self))
		self.x = x
		self.y = y
pt = Point(1, 2)
print(pt)

# вызов __new__ для <class '__main__.Point'
# None
```
> `cls` - ссылается на текущий экземпляр класса (`class Point`)
> `self` - ссылается на создаваемый экземпляр класса (экземпляр класса не создастся, т.к. мы переопределили магический метод `__new__`)

```Python
class Point:  
    def __new__(cls, *args, **kwargs):  
        print("вызов __new__ для " + str(cls))  
        return super().__new__(cls)  
  
    def __init__(self, x=0, y=0):  
        print("вызов __init__ для " + str(self))  
        self.x = x  
        self.y = y  
  
  
pt = Point(1, 2)  
print(pt)

# вызов __new__ для <class '__main__.Point'>
# вызов __init__ для <__main__.Point object at 0x000001C3F8448C50>
# <__main__.Point object at 0x000001C3F8448C50>
```
> все классы автоматически неявно наследуются от базового класса `object`, мы из него вызываем метод `__new__`

>[!Зачем нужен метод `__new__`?]
>[[Паттерн проектирования Singleton]]



`__init__` - инициализация экземпляра класса (вызывается сразу после создания экземпляра класса)
