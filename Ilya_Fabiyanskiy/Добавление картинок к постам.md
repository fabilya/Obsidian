Django — это огромная экосистема из всевозможных модулей, расширяющих возможности базового фреймворка. На сайте [PyPI.org](http://pypi.org/) размещены десятки тысяч расширений, в названии которых есть слово _django_, а неопубликованных модулей или тех, что названы как-то иначе — ещё больше.

Пустим в дело богатства экосистемы: подключим к проекту Yatube управление изображениями.

## Приложение для работы с картинками: sorl-thumbnail

В стандартную установку Django встроен инструмент для работы с картинками, но задачи вроде изменения размера изображений ему не по силам. Django умеет только загружать файлы и отдавать их как есть.

Для настоящей соцсети этого мало. Пользователи могут залить RAW-картинку размером 5950×3968 пикселей и весом в 50 Мб, или выложить картинку-мем размером в 120х80. Если опубликовать эти картинки в исходном виде — сайт будет выглядеть неопрятно или долго загружаться.

Дадим пользователям возможность иллюстрировать посты и сделаем так, чтобы загруженные изображения выглядели более-менее одинаково.

Одно из первых по популярности и удобству приложений для работы с графикой — библиотека [**sorl-thumbnail**](https://github.com/jazzband/sorl-thumbnail). Для его работы нужна графическая библиотека. Для **sorl-thumbnail** годятся многие библиотеки, мы возьмём **Pillow**.

> Когда Python ещё набирал популярность, в компании _Secret Labs AB_ написали библиотеку **PIL** (от _Python Imaging Library_). Это была одна из первых графических библиотек для Python. Она быстро стала стандартом в сообществе. Компания _Secret Labs AB_ перестала существовать, но потребность в обработке изображений никуда не пропала, и _Alex Clark_ сделал форк (ответвление проекта) под новым названием **Pillow** (англ. «подушка»); буквы _pil_ включены в название в честь старого проекта, а не потому, что Кларк любит поспать. Новая библиотека поддерживает совместимость и со старыми проектами.

Для установки Pillow выполните команду в виртуальном окружении проекта:

Скопировать код

```
(venv) $ pip install pillow 
```

> Возможно, вам понадобится [установить дополнительные библиотеки](https://pillow.readthedocs.io/en/latest/installation.html) для вашей операционной системы.

Теперь установите приложение `sorl-thumbnail`:

Скопировать код

```
(venv) $ pip install sorl-thumbnail 
```

Добавьте приложение в список `INSTALLED_APPS`, в конец списка:


```
INSTALLED_APPS = [
    # ... 
    'sorl.thumbnail',
] 
```

Выполните миграцию, после этого приложение будет готово к работе.

Теперь вам станут доступны специальные теги в шаблонах:


```
<!-- Загрузка тегов библиотеки в шаблон -->
{% load thumbnail %}

<!-- Пример использования тега для пропорционального уменьшения и обрезки -->
<!-- картинки до размера 100x100px с центрированием -->
{% thumbnail item.image "100x100" crop="center" as im %}
  <img src="{{ im.url }}" width="{{ im.width }}" height="{{ im.height }}">
{% endthumbnail %} 
```

Даже если у вас всё хорошо получается — [документация к приложению](https://github.com/jazzband/sorl-thumbnail) не будет лишней.

## Настройки проекта

Добавим в модель **Post** новое поле, чтобы к посту можно было добавить заглавную картинку:

Скопировать кодPYTHON

```

class Post(models.Model):
    text = models.TextField(
        'Текст поста',
        help_text='Введите текст поста'
    )
    pub_date = models.DateTimeField(
        'Дата публикации',
        auto_now_add=True
    )
    author = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        verbose_name='Автор'
    )
    group = models.ForeignKey(
        Group,
        on_delete=models.SET_NULL,
        related_name='posts',
        blank=True,
        null=True,
        verbose_name='Группа',
        help_text='Выберите группу'
    )
    # Поле для картинки (необязательное) 
    image = models.ImageField(
        'Картинка',
        upload_to='posts/',
        blank=True
    )  
    # Аргумент upload_to указывает директорию, 
    # в которую будут загружаться пользовательские файлы. 

    class Meta:
        ordering = ('-pub_date',)
        verbose_name = 'Пост'
        verbose_name_plural = 'Посты'

    def __str__(self):
        return self.text[:15] 
```

Путь в параметре `upload_to` указывается относительно адреса, указанного в _settings.py_ в `MEDIA_ROOT`: в нём устанавливают полный путь к директории, куда будут загружаться файлы пользователей: обычно её называют _media/_.

В этой директории может быть несколько папок: сейчас мы работаем с картинками, но как знать — возможно, завтра мы разрешим пользователям загружать архивы, текстовые файлы или видео. Загружаемые файлы лучше хранить в разных папках, в соответствии с их назначением.

Добавьте следующие строки в файл _settings.py_:

Скопировать кодPYTHON

```
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.2/howto/static-files/

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 
```

Для загрузки картинок установлен параметр `upload_to='posts/'`, таким образом картинки, прикреплённые к постам, будут сохраняться в директории _media/posts_.

Как всегда, после изменения модели сделайте миграции.

Теперь добавьте новое поле в форму, связанную с моделью:

Скопировать кодPYTHON

```
from django import forms

from .models import Post

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        # Добавили поле image в форму
        fields = ('group', 'text', 'image') 
```

При дефолтных настройках проекта в режиме разработчика Django не будет раздавать картинки, загруженные пользователями: обычно раздачей картинок занимается специальный сервер. Чтобы настроить отображение картинок — в _urls.py_ нужно переопределить поведение Django — указать, что в режиме `DEBUG=True` он должен брать картинки из директории, указанной в `MEDIA_ROOT`.

Добавьте в файл `yatube/urls.py` следующий код:

Скопировать кодPYTHON

```
# Эти строки — в начало файла, после импорта других модулей
from django.conf import settings
from django.conf.urls.static import static
...

# Эти строки — в самый конец файла:
if settings.DEBUG:
    urlpatterns += static(
        settings.MEDIA_URL, document_root=settings.MEDIA_ROOT
    )
 
```

Эта колдограмма будет работать, когда ваш сайт в режиме отладки. Он позволяет обращаться к файлам в директории, указанной в `MEDIA_ROOT` по имени, через префикс `MEDIA_URL`.

> Создайте директорию _media/_ вручную и добавьте её в _.gitignore_.

## Обновление шаблона

Чтобы изображение показывалось на странице сайта, измените шаблон страницы записи. Добавьте вывод картинок в `posts/post_detail.html`:

Скопировать код

```
{% load thumbnail %}
  ...
<article>
  <ul>
    <li>
      Автор: {{ post.author.get_full_name }} 
      <a href="{% url 'posts:profile' post.author %}">все посты пользователя</a>
    </li>
    <li>
      Дата публикации: {{ post.pub_date|date:"d E Y" }}
    </li>
  </ul>
  {% thumbnail post.image "960x339" crop="center" upscale=True as im %}
    <img class="card-img my-2" src="{{ im.url }}">
  {% endthumbnail %}
  <p>{{ post.text }}</p>
  <a href="{% url 'posts:post_detail' post.pk %}">подробная информация</a>
</article>
... 
```

Если в посте нет картинки, то содержимое тега `thumbnail` будет проигнорировано; проверку `{% if post.image %}...{% endif %}` делать не надо.

### Шаблон формы создания и редактирования поста

В HTML-форме создания и редактирования поста появится поле для загрузки изображения. Форма должна понимать, что из неё на сервер будут передаваться файлы. Обновите шаблон с формой — в HTML-тег `<form>` добавьте атрибут `enctype`:

Скопировать кодMARKDOWN

```
<form method="post" enctype="multipart/form-data">
  {% csrf_token %}
  {% for field in form %}
    ...
  {% endfor %} 
```

## Обновление view-функции

Осталось подправить view-функцию редактирования записи. Django-формы умеют работать с файлами. Нужно лишь передать дополнительный параметр `files=request.FILES or None`, и больше ничего! Вам не надо отдельно сохранять файлы, не надо проверять их тип или беспокоиться, что в директории загрузки окажется файл с таким же именем — Django сам переименует файл при необходимости:

Скопировать кодPYTHON

```
def post_edit(request, post_id):
    post = get_object_or_404(Post, pk=post_id)
    if post.author != request.user:
        return redirect('posts:post_detail', post_id=post_id)

    form = PostForm(
        request.POST or None,
        files=request.FILES or None,
        instance=post
    )
    if form.is_valid():
        form.save()
        return redirect('posts:post_detail', post_id=post_id)
    context = {
        'post': post,
        'form': form,
        'is_edit': True,
    }
    return render(request, 'posts/create_post.html', context) 
```

## Результат

Создайте новый пост, загрузите картинку-иллюстрацию. Страница нового поста должна выглядеть примерно так:

![image](https://pictures.s3.yandex.net/resources/leo_1632994398.jpg)

## Задание

При работе ориентируйтесь на дизайн шаблонов из [этого архива](https://code.s3.yandex.net/backend-developer/learning-materials/delugov/html-templates61.zip).

### 1. Выведите иллюстрации к постам:

-   в шаблон главной страницы
-   в шаблон профайла автора
-   в шаблон страницы группы

Команду `{% load thumbnail %}` достаточно выполнить один раз в начале файла.

Проверьте шаблоны с постами, формы редактирования и создания постов: отображение страниц должно соответствовать дизайну из приложенного архива.

### 2. Напишите тесты, которые:

-   проверяют, что при выводе поста с картинкой изображение передаётся в словаре `context`
    -   на главную страницу,
    -   на страницу профайла,
    -   на страницу группы,
    -   на отдельную страницу поста;
-   проверяют, что при отправке поста с картинкой через форму **PostForm** создаётся запись в базе данных.

Из урока по тестированию форм вы знаете, как загрузить картинку на сервер и при этом не замусорить проект тестовыми данными. Здесь это знание вам очень пригодится.