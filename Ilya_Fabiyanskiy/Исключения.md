**Исключение** (англ. _Exception_) — это объект в Python, который указывает на какую-то ошибку.

Один из простых способов вызвать исключение — разделить число на ноль. При этом интерпретатор выведет в консоль **трейсбек** (англ. _traceback,_ от _trace back —_ «отслеживать»**),** цепочку функций, которые были вызваны перед появлением ошибки.

Обычно трейсбек бывает длинным и иерархическим: в программе могут вызываться разные функции из разных пакетов. Но он может быть и лаконичным:

```
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero 
```

Этот трейсбек показывает, что в первой строке кода произошла ошибка деления на ноль, получено исключение _ZeroDivisionError_ и выполнение программы остановлено.

В Python [есть множество встроенных исключений](https://docs.python.org/3/library/exceptions.html), и с некоторыми из них вы уже сталкивались. Вероятно, в топе популярности было исключение **SyntaxError**: оно возникает при синтаксических ошибках и не требует программной обработки — нужно просто поправить код.

Все исключения наследуются от базового класса **Exception**, расширяя его. Иерархия исключений [приведена в документации](https://docs.python.org/3/library/exceptions.html#exception-hierarchy).

Хорошей практикой считается создавать свои собственные исключения там, где они необходимы. **Исключение** — это класс, унаследованный от базового класса Exception либо от его дочернего класса, подходящего для решения задачи.

Создадим собственное исключение и применим его:


```
class NegativeValueException(Exception):
    pass

def set_robot_power(value):
    if value < 0:
        raise NegativeValueException('Введите число, которое больше нуля!')

set_robot_power(-1) 
```

Исключения останавливают выполнение программы, но разработчик может указать программе, как их обработать — и тогда при ошибке выполнение программы не прервётся. Такая обработка ошибок называется **перехват исключений**.

## Работа над ошибками

Есть два подхода к обработке ошибок:

-   **Look Before You Leap** (LBYL) — «посмотри, прежде чем прыгнуть»: заранее предусмотри возможные ошибки;
-   **Easier to Ask for Forgiveness than Permission** (EAFP) — «лучше просить прощения, чем разрешения»: перехвати ошибку, если она произошла.

### Заранее предусмотри ошибки

Этот подход заключается в том, чтобы просчитать все возможные ситуации. Известно, что на ноль делить нельзя, значит, перед операцией деления нужно проверить, что делитель не равен нулю:

Скопировать кодPYTHON

```
if divisor != 0:
    result = numerator / divisor
else:
    result = None 
```

А в случае с чтением файла сперва нужно убедиться, что файл существует, и только затем открывать его.

### Перехвати ошибку

Этот подход более универсален и гибок: в блоке кода заранее описывается поведение на тот случай, если что-то пойдёт не так; разработчик предполагает, что всё будет работать, но на всякий случай описывает запасной вариант:

Скопировать кодPYTHON

```
try:
    result = numerator / divisor 

except ZeroDivisionError:
    # В случае, если появится ошибка ZeroDivisionError - 
    # сделай вот что:
    result = None
    print('На ноль делить нельзя!') 
```

Синтаксис здесь такой:

Скопировать кодPYTHON

```
try:
    # Выполняем этот блок кода
except <определённая разновидность исключений>:
    # Выполняем этот блок, если возникло определённое исключение,
    # таких блоков может быть много
except <другая разновидность исключений>:
    # Выполняем этот блок, если возникло определённое исключение,
    # таких блоков может быть много
except Exception:
    # Выполняем этот блок, если возникло исключение, отличное от описанных выше
else:
    # Выполняем этот блок, если не возникло исключений (опциональный блок)
finally:
    # Этот блок выполнится всегда (опциональный блок)
 
```

В блоке `try` пишется основной код, который может вызвать исключение. За ним следует один или несколько блоков `except`, в которых описан код, который сработает при том или ином типе исключения. Лучше всегда указывать тип исключения явно — это хорошая практика. Информацию о возможных исключениях, как правило, можно найти в документации к сервису, с которым вы взаимодействуете.

«П» — «предусмотрительность»: если в коде обрабатывается список list, то стоит учесть ситуацию, что в списке не окажется запрошенного элемента; значит, надо перехватить исключение _IndexError._ Точно так же при обращении к ключу словаря нужно предусмотреть исключение _KeyError_ и перехватить его.

## Работа с исключениями в KittyBot

При запросе к внешнему API-сервису thecatapi.com необходимо обработать исключения: ведь нет гарантий, что запрос пройдёт успешно.

Если по каким-либо причинам сервис не вернёт ожидаемый ответ — не будем сообщать пользователю об ошибке, а чтобы он сильно не расстраивался — отправим ему, в качестве компенсации, фото пёсика с сервиса [thedogapi.com](http://thedogapi.com/) (есть и такой API-сервис, он работает так же, как и API с котиками).

Добавим перехват исключений в функцию `get_new_image()`: при появлении ошибки напечатаем её в консоли и запросим фото с сервиса thedogapi.com.

Скопировать кодPYTHON

```
def get_new_image():
    try:
        response = requests.get(URL)
    except Exception as error:
        print(error)      
        new_url = 'https://api.thedogapi.com/v1/images/search'
        response = requests.get(new_url)
    
    response = response.json()
    random_cat = response[0].get('url')
    return random_cat 
```

При возникновении исключения создаётся экземпляр класса Exception. Конструкция `Exception as error` связывает этот экземпляр с переменной `error`. Строковое представление экземпляра исключения — это текстовое сообщение об ошибке; в результате выполнения строки `print(error)` это сообщение и будет напечатано.

KittyBot продолжит работать по-прежнему, но если с API-сервисом котиков что-то случится, то вместо котика пользователь получит изображение собачки.

Чтобы проверить работу кода — присвойте константе URL пустую строку и перезапустите бота.

### ПРИМЕР:

```
def just_plus(first, second):
    # Ожидаются параметры одинакового типа.
    # В ином случае должна выбрасываться ошибка.
    try:
        print(first + second)
    except TypeError:
        print('Переданы параметры разного типа!')

        
first = 5
second = 10
just_plus(first, second)
```
