## Предустановленный класс для работы с моделями: Viewset

На прошлом уроке вы реализовали все типовые операции CRUD, для этого потребовалось лишь два класса-дженерика и два эндпоинта. Шесть операций упакованы в два класса — неплохо, но можно лучше.

Всякий раз, когда снова потребуется реализовать CRUD, придётся снова и снова описывать тот же набор из аналогичных классов. А почему бы не описать всё в одном классе?

И когда у кого-то возник этот вопрос — появились **вьюсеты**.

Вьюсет (англ. _viewset_, «набор представлений») — это высокоуровневый view-класс, реализующий все операции CRUD; он может вернуть объект или список объектов, создать, изменить или удалить объекты.

Во вьюсеты встроена обработка разных типов запросов, работа с сериализаторами и моделями, фильтрация и пагинация результатов, возврат ошибок. Не нужно ничего придумывать: всё работает «из коробки».

В библиотеке `rest_framework` есть несколько разных вьюсетов, они хранятся в пакете `viewsets`.

Начнём с самого популярного вьюсета. Встречайте: **ModelViewSet**.

## Универсальный ModelViewSet

Класс **ModelViewSet** может выполнять любые операции CRUD с моделью. От разработчика не требуется описывать методы для чтения и записи данных для модели: эти операции уже реализованы.

В классе, наследующемся от `ModelViewSet`, обязательно должны быть описаны два поля:

-   в поле `queryset` задаётся выборка объектов модели, с которой будет работать вьюсет;
-   в поле `serializer_class` указывается, какой сериализатор будет применён для валидации и сериализации.

И во второй раз перепишем Kittygram: вместо дженериков применим вьюсеты.

> Это практическая работа: вносите изменения, описанные в этом уроке, в проект Kittygram, развёрнутый на вашем компьютере.

В начале работы нужно импортировать пакет `viewsets` и создать класс, наследующийся от **ModelViewSet**.

Скопировать кодPYTHON

```
# views.py
from rest_framework import viewsets 

from .models import Cat
from .serializers import CatSerializer


class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer 
```

Всё.

Класс, который обработает все шесть типичных действий, готов.

Класс `ModelViewSet` предоставляет отличный набор инструментов для всех востребованных операций при работе с моделями. В большинстве стандартных ситуаций он будет работать «из коробки».

Выгода очевидна.

## Класс ReadOnlyModelViewSet: только чтение

В пакете rest_framework.viewsets есть похожий на `ModelViewSet`, но ограниченный в правах класс `ReadOnlyModelViewSet`. Он может только получать данные модели, а записывать и изменять — не может.

Этот класс полезен в ситуациях, когда требуется только выдавать данные по запросу, без возможности их изменить. В остальном `ReadOnlyModelViewSet` работает точно так же, как и `ModelViewSet`.

## Роутеры

При работе с view-классами и дженериками каждый эндпоинт отдельно описывается в _urls.py_. Но для вьюсетов есть более удобный и экономичный инструмент — **роутеры** (англ. _routers_).

С помощью роутера для заданных вьюсетов создаются эндпоинты по маске адреса:

-   `URL-префикс/` и
-   `URL-префикс/<int:pk>`.

В DRF есть два стандартных роутера: **SimpleRouter** и **DefaultRouter**. Они очень похожи, начнём с первого.

Добавьте роутеры в Kittygram. В файл _urls.py_ импортируйте класс `SimpleRouter` и создайте экземпляр этого класса.

Скопировать кодPYTHON

```
# urls.py
from rest_framework.routers import SimpleRouter

router = SimpleRouter() 
```

Чтобы роутер создал необходимый набор эндпоинтов, необходимо вызвать его метод register() (говорят «зарегистрировать эндпоинты»). В качестве аргументов этот метод принимает URL-префикс и название вьюсета, для которого создаётся набор эндпоинтов.

Скопировать кодPYTHON

```
router.register('cats', CatViewSet) 
```

После регистрации надо включить новые эндпоинты в список `urlpatterns`: перечень эндпоинтов будет доступен в `router.urls`.

Создание эндпоинтов через router выглядит так:

Скопировать кодPYTHON

```
# urls.py
from rest_framework.routers import SimpleRouter

from django.urls import include, path

from cats.views import CatViewSet

# Создаётся роутер
router = SimpleRouter()
# Вызываем метод .register с нужными параметрами
router.register('cats', CatViewSet)
# В роутере можно зарегистрировать любое количество пар "URL, viewset":
# например
# router.register('owners', OwnerViewSet)
# Но нам это пока не нужно

urlpatterns = [
    # Все зарегистрированные в router пути доступны в router.urls
    # Включим их в головной urls.py
    path('', include(router.urls)),
] 
```

Только что созданный роутер сгенерирует два эндпоинта:

-   `cats/`,
-   `cats/<int:pk>/`.

Теперь через эти эндпоинты будут доступны любые операции с моделью:

-   POST-запрос на `cats/` создаст новую запись.
-   Запросы PUT, PATCH или DELETE к адресу `cats/<pk>/` изменят или удалят существующую запись.
-   GET-запрос на те же адреса вернёт список объектов или один объект.

## Параметр name в эндпоинтах

В _urls.py_ для каждого маршрута можно указать необязательный параметр `name`. Если этот параметр определён, то во view-функциях или view-классах через функцию `reverse()` можно получить соответствующие URL — это очень удобно и соответствует принципу DRY.

На практике вы уже работали с этими функциями при написании тестов для Django-проекта; при тестировании API `name` в эндпоинтах вам тоже понадобятся.

Роутеры сами автоматически создают `name` для каждого эндпоинта, его значение создаётся

-   из имени модели, с которой работает вьюсет,
-   и суффикса:
    -   _-list_ (для эндпоинта, работающего с коллекцией объектов)
    -   или _-detail_ (для эндпоинта, работающего отдельным объектом).

Например, для роутера, созданного для вьюсета `CatViewSet()`.

Скопировать кодPYTHON

```
class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer 
```

имена эндпоинтов будут такими:

Скопировать кодPYTHON

```
urlpatterns = [
    # Здесь имя "cat" взято из queryset, 
    # с которым работает вьюсет CatViewSet
    path('cat/', ..., name='cat-list'),
    path('cat/<int:pk>/', ..., name='cat-detail'),
] 
```

При работе с вьюсетами и роутерами вы можете столкнуться с ошибкой «не определён аргумент basename»:

Скопировать кодBASH

```
'basename' argument not specified, and could not automatically determine the name from the viewset, as it does not have a '.queryset' attribute. 
```

Речь идёт о необязательном аргументе роутера `basename`: в нём можно вручную указать префикс для параметра `name` в эндпоинтах, созданных роутером.

Например, можно переопределить префикс _cat_ в `name='cat-list'` и `name='cat-detail'`

Скопировать кодPYTHON

```
router.register('cats', CatViewSet, basename='tiger') 
```

В результате `name` для эндпоинтов будут начинаться с tiger:

Скопировать кодPYTHON

```
urlpatterns = [
    path('cat/', ..., name='tiger-list'),
    path('cat/<int:pk>/', ..., name='tiger-detail'),
] 
```

Однако есть случаи, когда параметр `basename` обязательно должен быть указан. Это необходимо в тех случаях, когда queryset однозначно не задан во вьюсете, а определён через метод `get_queryset()`.

Скопировать кодPYTHON

```
# Если бы пользователи могли оставлять комментарии к котикам, 
# то эндпоинт для работы с комментариями выглядел бы примерно так:
# cats/{cat_id}/comments/

class CommentViewSet(viewsets.ModelViewSet):
    serializer_class = CommentSerializer
    # queryset во вьюсете не указываем
    # Нам тут нужны не все комментарии, а только связанные с котом с id=cat_id
    # Поэтому нужно переопределить метод get_queryset и применить фильтр
    def get_queryset(self):
        # Получаем id котика из эндпоинта
        cat_id = self.kwargs.get("cat_id")
        # И отбираем только нужные комментарии
        new_queryset = Comment.objects.filter(cat=cat_id)
        return new_queryset 
```

В подобных ситуациях создать `name` автоматически не получится, и параметр `basename` придётся указать явным образом.

## SimpleRouter vs DefaultRouter

**DefaultRouter** — это расширенная версия SimpleRouter: он умеет всё то же, что и SimpleRouter, а в дополнение ко всему генерирует корневой эндпоинт `/`, GET-запрос к которому вернёт список ссылок на все ресурсы, доcтупные в API.

У этого эндпоинта тоже есть `name`: `api-root`. Маршрут для него мог бы выглядеть примерно так:

Скопировать кодPYTHON

```
urlpatterns = [
    ...
    path('', ..., name='api-root'),
] 
```

Если применён DefaultRouter, то в ответ на GET-запрос к адресу [http://127.0.0.1:8000/](http://127.0.0.1:8000/) вернётся список ссылок на доступные ресурсы.

![image](https://pictures.s3.yandex.net/resources/Untitled_1623745442.png)

При работе с документированием вам потребуется получить коллекцию ссылок на все ресурсы API, так что далее в курсе будем работать именно с **DefaultRouter**.

# Вьюсеты. Расширенные возможности

Бытует мнение, что у котиков с доминирующим белым окрасом голубой цвет глаз более глубокий, чем у остальных, и это считается достоинством. Вот именно они и представляют интерес для наших пользователей.

В связи с повышенным спросом на белых котиков требуется расширить возможности API: по специальному запросу нужно отдавать информацию о пяти последних добавленных котиках белого цвета. Для таких запросов уже придумали эндпоинт: `cats/recent-white-cats/`.

Задача не выглядит типичной: можно получить данные о всех котиках или о каком-то одном, но не о пяти, да ещё и определённого цвета.

## Нестандартные действия во вьюсетах

Ещё раз переберём список стандартных действий (англ. _actions_) во вьюсетах:

-   _create_: создание экземпляра;
-   _retrieve_: получение экземпляра;
-   _list_: получение списка экземпляров;
-   _update_: обновление экземпляра (все поля);
-   _partial_update_: обновление экземпляра (только выбранные поля);
-   _destroy_: удаление экземпляра.

Для поставленной задачи ни один из них не подойдёт.

Необходимо нестандартное действие; для этого во вьюсете пишут отдельные методы, которые оборачивают в декоратор `@action` («действие»). Этот декоратор настраивает метод и создаёт эндпоинты для этих действий.

Имя такого метода-«действия» может быть произвольным.

Декоратор `@action` по умолчанию отслеживает только GET-запрос. Но если передать в декоратор параметр `methods`, то можно разрешить и другие методы запросов.

Скопировать кодPYTHON

```
@action(methods=['get', 'delete', ...] 
```

В декораторе можно явным образом указать, должен ли метод работать с одним объектом или с коллекцией объектов. Для этого используется параметр `detail`, который может принимать значения `True` (разрешена работа с одним объектом) или `False` (работаем с коллекцией).

URL эндпоинта по умолчанию генерируется из двух частей: `<URL-префикс ресурса>/<название метода>/`.

Скопировать кодPYTHON

```
# К такому методу можно обратиться через эндпоинт cats/cats_for_sale/
@action()
def cats_for_sale()
    ... 
```

Если URL эндпоинта не должен совпадать с именем метода, URL можно изменить: для этого нужно передать в декоратор аргумент `url_path` с необходимым значением.

Решим задачу с получением последних пяти белых котиков. Для этого опишем метод `recent_white_cats` для вьюсета `CatViewSet`.

Скопировать кодPYTHON

```
from rest_framework.decorators import action
from rest_framework.response import Response

...

class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer

    # Пишем метод, а в декораторе разрешим работу со списком объектов
    # и переопределим URL на более презентабельный
    @action(detail=False, url_path='recent-white-cats')
    def recent_white_cats(self, request):
        # Нужны только последние пять котиков белого цвета
        cats = Cat.objects.filter(color='White')[:5]
        # Передадим queryset cats сериализатору 
        # и разрешим работу со списком объектов
        serializer = self.get_serializer(cats, many=True)
        return Response(serializer.data) 
```

Готово, проверяем.

При отправке GET-запроса на эндпоинт `cats/recent-white-cats/` должен быть получен примерно такой результат (конечно, если у вас в базе есть достаточно белых котиков):

![image](https://pictures.s3.yandex.net/resources/Untitled_1623750954.png)

## Различные сериализаторы для одного вьюсета

В Kittygram для сериализации и десериализации каждой модели использовался лишь один сериализатор. Но если некоторые поля сериализатора доступны только для чтения, то по факту для чтения применяется один набор полей, а для записи — другой. Это равносильно использованию разных сериализаторов.

Да, так тоже можно: для модели можно описать несколько сериализаторов и использовать их, например, в зависимости от типа запроса.

Допустим, когда

-   добавляется новый котик,
-   запрашивается детальная информация о конкретном котике,
-   обновляется информация о конкретном котике,

будем обрабатывать все доступные поля модели, а вот если запрашивается список котиков, то необходимы только id, имя и цвет.

Опишем для этого ещё один сериализатор, который назовём `CatListSerializer`:

Скопировать кодPYTHON

```
class CatListSerializer(serializers.ModelSerializer):
    color = serializers.ChoiceField(choices=CHOICES)
    
    class Meta:
        model = Cat
        fields = ('id', 'name', 'color') 
```

Добавьте во вьюсет стандартный метод `get_serializer_class`: в нём можно определить, какой из доступных сериализаторов должен обрабатывать данные в зависимости от действия:

Скопировать кодPYTHON

```
class CatViewSet(viewsets.ModelViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer

    ...
    
    def get_serializer_class(self):
        # Если запрошенное действие (action) — получение списка объектов ('list')
        if self.action == 'list':
            # ...то применяем CatListSerializer
            return CatListSerializer
        # А если запрошенное действие — не 'list', применяем CatSerializer
        return CatSerializer 
```

Проверим результаты, отправив GET-запрос на получение списка всех котиков.

![image](https://pictures.s3.yandex.net/resources/Untitled_1_1623750956.png)

По ответу видно, что отработал новый сериализатор: всё по плану. А при запросе к конкретному котику всё работает как и раньше:

![image](https://pictures.s3.yandex.net/resources/Untitled_2_1623750959.png)

## Нестандартный набор стандартных действий

Чаще всего мы наследовали вьюсеты от `ModelViewSet`. По умолчанию это даёт возможность обрабатывать шесть типичных действий:

-   создание нового объекта;
-   получение информации об одном объекте;
-   удаление объекта;
-   полное замещение существующего объекта;
-   изменение одного или нескольких полей объекта;
-   получение списка объектов.

Если требуется только получать данные из БД, можно унаследоваться от `ReadOnlyModelViewSet`. В этом случае доступный набор действий будет таким:

-   получение информации об одном объекте;
-   получение списка объектов.

А если требуется иной набор действий — например, нужно только создавать новый объект и получать информацию об одном объекте? Эта задача может быть решена с использованием миксинов (от англ. mix in, «смешивать»).

## Миксины и ваш собственный базовый класс для вьюсетов

Никто не знает, что придёт в голову разработчикам и какие вьюсеты им понадобятся, поэтому готовых вьюсетов на все случаи жизни нет и быть не может. Но есть классы-«детали», из которых можно быстро собрать практически любой необходимый базовый вьюсет: **миксины**.

Чтобы самостоятельно создать базовый вьюсет с особым набором действий — нужно унаследовать его от одного или нескольких миксинов с нужными действиями и, дополнительно, от базового класса `GenericViewSet`:

Скопировать кодPYTHON

```
from rest_framework import mixins

...

# Собираем вьюсет, который будет уметь изменять или удалять отдельный объект.
# А ничего больше он уметь не будет.
class UpdateDeleteViewSet(mixins.UpdateModelMixin, mixins.DestroyModelMixin,
                          viewsets.GenericViewSet):
    pass 
```

В DRF есть пять предустановленных классов миксинов, они соответствуют пяти операциям с данными:

-   CreateModelMixin — создать объект (для обработки запросов POST);
-   ListModelMixin — вернуть список объектов (для обработки запросов GET);
-   RetrieveModelMixin — вернуть объект (для обработки запросов GET);
-   UpdateModelMixin — изменить объект (для обработки запросов PUT и PATCH);
-   DestroyModelMixin — удалить объект (для обработки запросов DELETE).

Опишем собственный базовый класс вьюсета: он будет создавать экземпляр объекта и получать экземпляр объекта; назовём его `CreateRetrieveViewSet`.

Скопировать кодPYTHON

```
# cats/views.py
...

from rest_framework import mixins

...

class CreateRetrieveViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin,
                            viewsets.GenericViewSet):
    # В теле класса никакой код не нужен! Пустячок, а приятно.
    pass 
```

Базовый вьюсет готов, он получился не хуже, чем `ModelViewSet`. Теперь можно унаследоваться от этого базового класса.

Опишем вьюсет `LightCatViewSet`, унаследованный от `CreateRetrieveViewSet`.

Скопировать кодPYTHON

```
class LightCatViewSet(CreateRetrieveViewSet):
    queryset = Cat.objects.all()
    serializer_class = CatSerializer 
```

Зарегистрируем этот вьюсет в роутере:

Скопировать кодPYTHON

```
from cats.views import CatViewSet, LightCatViewSet, OwnerViewSet

...

router.register(r'mycats', LightCatViewSet) 
```

Нужно разобраться, что за странный синтаксис в первом аргументе метода `register()`, ведь там должен быть просто префикс для URL.

## Неожиданное откровение

При регистрации эндпоинтов для вьюсета в качестве URL-префикса используется не обычная строка, а **регулярное выражение**. За счёт этого URL-префикс может обрабатывать множество вариантов URL.

Скопировать кодPYTHON

```
...
# При регистрации эндпоинтов с таким URL-префиксом
router.register(r'profile/(?P<username>[\w.@+-]+)/', AnyViewSet)
# ...вьюсет AnyViewSet будет получать на обработку все запросы с адресов
# /profile/toh@/
# /profile/nik.nik/
# /profile/leo/
# ...и подобных, ограниченных маской регулярного выражения. 
```

В уроке о роутерах в первый параметр метода `register()` мы передавали просто строку, но «просто строка» — это частный случай регулярного выражения, и Django эту «просто строку» тоже интерпретировал как regExp.

Префикс `r` перед строкой определяет **raw-строку** (или **r-строку**, так короче). Такую строку система будет читать как простую последовательность символов, игнорируя escape-последовательности (англ. _escape sequence)_ — комбинации обратного слеша и символа.

Например, escape-последовательность `\n` интерпретируется как перенос строки, но в raw-строке это будут просто два текстовых символа без всякого скрытого смысла; в результате вся r-строка будет считана как регулярное выражение.

## Вернёмся к нашим миксинам

Базовый вьюсет собран, наследник описан и применён в коде.

Проверьте работу нового вьюсета: сделайте запросы на новый эндпоинт `mycats/`.

GET-запрос к конкретному котику отрабатывает на «отлично»:

![image](https://pictures.s3.yandex.net/resources/Untitled_3_1623750961.png)

А вот получить список котиков через этот эндпоинт нельзя:

![image](https://pictures.s3.yandex.net/resources/Untitled_4_1623750963.png)

Работает! Теперь можно монтировать базовые вьюсеты с любым набором действий.

## Мой вьюсет — мои правила: наследование от класса ViewSet

В тех случаях, когда нужно получить больше контроля и возможностей что-то «подкрутить» во вьюсетах, можно наследоваться от базового класса `ViewSet`. Именно от него наследуется, например, класс `ModelViewSet`.

Класс `ViewSet`, в свою очередь, наследуется от `APIView`.

При работе с низкоуровневыми вьюсетами все нужные методы вам придётся описать самостоятельно.

В классе `ViewSet` есть шесть предопределённых методов:

-   **list(self, request)** — для получения списка объектов из _queryset;_
-   **create(self, request)** — для создания объекта в модели;
-   **retrieve(self, request, pk=None)** — для получения определённого объекта из _queryset_;
-   **update(self, request, pk=None)** — для перезаписи (полного обновления) определённого объекта из _queryset_;
-   **partial_update(self, request, pk=None)** — для частичного обновления объекта из _queryset_;
-   **destroy(self, request, pk=None)** — для удаления одного из объектов _queryset._

Чтобы применить любой из этих методов, нужно полностью описать его; в классе `ViewSet` эти методы объявлены, но не описаны.

Например, в приложении нужно создать вьюсет, который будет получать сериализованный объект одного котика (методом `retrieve()`) и полный список всех котиков (методом `list()`). Это можно сделать так:

Скопировать кодPYTHON

```
from rest_framework import viewsets
from rest_framework.response import Response

from django.shortcuts import get_object_or_404

from .models import Cat
from .serializers import CatSerializer


class CatViewSet(viewsets.ViewSet):
    def list(self, request):
        queryset = Cat.objects.all()
        serializer = CatSerializer(queryset, many=True)
        return Response(serializer.data)

    def retrieve(self, request, pk=None):
        queryset = Cat.objects.all()
        cat = get_object_or_404(queryset, pk=pk)
        serializer = CatSerializer(cat)
        return Response(serializer.data) 
```

Похоже на то, как мы работали в APIView, с той разницей, что здесь присутствуют поля _queryset_ и _serializer_.

Документацию по предустановленным методам класса `ViewSet` можно [посмотреть на официальном сайте проекта](https://www.django-rest-framework.org/api-guide/viewsets/#viewset-actions).