В переводе с английского **log** — это «журнал». **Логирование** — это ведение «бортового журнала», автоматическая запись событий в специальный файл или вывод таких записей в терминал.

Логи — это дополнительная система мониторинга; разработчик может настроить логирование в тех частях кода, за которыми нужно присматривать.

С помощью логов можно не просто выводить сообщения об ошибке, но и сортировать сообщения по степени важности, записывать время события или другую служебную информацию о нём. В логах могут быть тысячи записей, но если известно, в какой период времени случилась ошибка — можно найти записи за этот период и выяснить, что там произошло.

![image](https://pictures.s3.yandex.net/resources/6_1631511208.png)

Логи позволяют делать то же, что и `print()`, но работают гибче и удобнее. Отладка кода через `print()` в приличном обществе считается дурным тоном.

Разберёмся, как работает логирование в Python и настроим логи в проекте KittyBot.

## Библиотека logging в Python

В Python есть [встроенная библиотека для логирования](https://docs.python.org/3/library/logging.html). Она умеет всё, что нужно для работы с логами — включать и выключать логирование, сортировать логи по важности, настраивать их внешний вид, записывать сообщения в файл и избавляться от старых записей, которые зря занимают место на диске.

## Настройка логов

Настроить логирование можно глобально, а можно определить настройки точечно, например — для каждого пакета в отдельности.

### Глобальная настройка

Глобально определить настройки логирования можно через метод `basicConfig()`. У этого метода есть три основных параметра:

-   `level` — уровень логирования;
-   `filename` — файл, в котором будут сохраняться логи;
-   `format` — вид, в котором мы сохраняем результат.

### Уровни логирования: «Внимание, красный уровень!»

Сообщениям в логах можно присвоить «уровень», степень важности логируемого события. По умолчанию в библиотеке _logging_ задано пять таких уровней. Обычно этого бывает достаточно, но, при необходимости, можно создать свой уровень.

Разные уровни нужны для сортировки сообщений по важности. Это облегчает поиск и работу с сообщениями.

**DEBUG** — уровень отладки. На этом уровне выводится всякая служебная информация: «Произошёл запуск функции», «Переменная содержит такое-то значение». Это сообщения о том, что происходит в коде, информация для разработчика.

**INFO** — информация о текущих событиях. Этот уровень применяют, если нужно убедиться, что всё идёт по плану: «Письмо отправлено», «Запись в базе создана».

**WARNING** — «тревожный звоночек»: проблемы нет, но есть что-то, что может привести к проблеме; что-то, на что следует обратить внимание.

**ERROR** — это ошибка: что-то работает не так, как нужно. Требуется вмешательство и исправление ошибки.

**CRITICAL** — случилось что-то совсем критичное: надо всё бросать и бежать к компьютеру; всё сломалось. Не очень часто используется на практике, обычно бывает достаточно ERROR.

Создайте и запустите на исполнение файл с таким кодом:


```
# example_for_log.py

import logging

logging.debug('123')  # Когда нужна отладочная информация 
logging.info('Сообщение отправлено')  # Когда нужна дополнительная информация
logging.warning('Большая нагрузка!')  # Когда что-то идёт не так, но работает
logging.error('Бот не смог отправить сообщение')  # Когда что-то сломалось
logging.critical('Всё упало! Зовите админа!1!111')  # Когда всё совсем плохо 
```

Логи будут выведены в терминал в таком формате:


```
УРОВЕНЬ_ВАЖНОСТИ:текущий_пользователь:сообщение 
```

После выполнения программы в терминале будет выведено:

```
WARNING:root:Большая нагрузка!
ERROR:root:Бот не смог отправить сообщение
CRITICAL:root:Всё упало! Зовите админа!1!111 
```

По умолчанию в терминал выводятся логи уровня WARNING, ERROR и CRITICAL. Уровни DEBUG и INFO предназначены для текущего информирования и, как правило, нужны разработчику лишь при отладке кода, поэтому по умолчанию в терминал не выводятся.

Это поведение можно изменить, вызвав метод `basicConfig()` и передав в параметр `level` уровень, с которого нужно фиксировать сообщения:

Скопировать кодPYTHON

```
import logging

# Здесь задана глобальная конфигурация для логирования
logging.basicConfig(level=logging.INFO)
... 
```

Сообщения уровня INFO теперь тоже будут выводиться в терминал:

Скопировать кодBASH

```
INFO:root:Сообщение отправлено
WARNING:root:Большая нагрузка!
ERROR:root:Бот не смог отправить сообщение
CRITICAL:root:Всё упало! Зовите админа!1!111 
```

### Сохранение логов в файл

Чтобы сохранять лог-сообщения в файл, нужно передать соответствующие параметры в метод `basicConfig()`, указав имя файла с расширением _.log_ и режим записи:

Скопировать кодPYTHON

```
# example_for_log.py

import logging

# Здесь задана глобальная конфигурация для логирования
logging.basicConfig(
    level=logging.DEBUG,
    filename='main.log',
    filemode='w'
)

logging.debug('123')
logging.info('Сообщение отправлено')
logging.warning('Большая нагрузка!')
logging.error('Бот не смог отправить сообщение')
logging.critical('Всё упало! Зовите админа!1!111') 
```

Значения параметра `filemode`:

`w` — содержимое файла перезаписывается при каждом запуске программы;

`x` — создать файл и записывать логи в него; если файл с таким именем уже существует — возникнет ошибка;

`a` — дописывать новые логи в конец указанного файла.

В результате выполнения скрипта в текущей директории будет создан файл _main.log_, и в него будут записываться все события.

![image](https://pictures.s3.yandex.net/resources/S8_27_1632740639.png)

### Форматирование логов

По умолчанию логи записываются в таком формате:

Скопировать кодPYTHON

```
УРОВЕНЬ ВАЖНОСТИ:текущий пользователь:сообщение 
```

Этот формат тоже можно изменить: в метод `basicConfig()` передаётся параметр format, а в нём описывается формат сообщения.

Скопировать кодPYTHON

```
# example_for_log.py

import logging

# Здесь задана глобальная конфигурация для логирования
logging.basicConfig(
    level=logging.DEBUG,
    filename='program.log', 
    format='%(asctime)s, %(levelname)s, %(message)s, %(name)s'
)
... 
```

**asctime** — время события,

**levelname** — уровень важности,

**message** — текст сообщения,

**name** — имя логгера.

Для описания атрибутов используется [«%-форматирование»](https://docs.python.org/3/library/string.html#format-specification-mini-language): атрибут берётся в скобки, перед скобками ставится символ `%`, а после скобок указывают тип данных. Например:

`s` — строка (_string_),

`d` — число (_digit_).

![image](https://pictures.s3.yandex.net/resources/S8_28_1632740663.png)

Помимо времени и уровня есть и другие полезные атрибуты для форматирования логов:

**filename** — имя файла, из которого отправлено сообщение в лог;

**funcName** — имя функции, из которой отправлено сообщение в лог;

**lineno** — номер строки в том файле, из которого сообщение отправлено в лог.

Полный список атрибутов [приведён в официальной документации](https://docs.python.org/3/library/logging.html#logrecord-attributes).

### Логгер

Метод `basicConfig()` — это самый быстрый способ для глобальной настройки логирования. Тем не менее в официальной документации рекомендуется создавать отдельные **логгеры** для каждого модуля приложения. В этом случае каждый логгер можно сконфигурировать индивидуально.

Логгер — это такая коробка или корзина, в которую Python скидывает лог-сообщения.

Логгеров может быть несколько: обычно пишут отдельный логгер для каждого пакета. Имя логгерам традиционно дают по имени `__name__` пакета, для которого он создан.

Скопировать кодPYTHON

```
# example_for_log.py

import logging

# В переменной __name__ хранится имя пакета; 
# это же имя будет присвоено логгеру.
# Это имя будет передаваться в логи, в аргумент %(name)
logger = logging.getLogger(__name__)

... 
```

Когда в проекте больше одного пакета — такая структура логирования упрощает работу.

Для каждого логгера можно задать:

-   level — уровень логирования;
-   handler — обработчик.

Скопировать кодPYTHON

```
# example_for_log.py

import logging

from logging.handlers import RotatingFileHandler

# Здесь задана глобальная конфигурация для всех логгеров
logging.basicConfig(
    level=logging.DEBUG,
    filename='program.log', 
    format='%(asctime)s, %(levelname)s, %(message)s, %(name)s'
)

# А тут установлены настройки логгера для текущего файла - example_for_log.py
logger = logging.getLogger(__name__)
# Устанавливаем уровень, с которого логи будут сохраняться в файл
logger.setLevel(logging.INFO)
# Указываем обработчик логов
handler = RotatingFileHandler('my_logger.log', maxBytes=50000000, backupCount=5)
logger.addHandler(handler)

logger.debug('123')
logger.info('Сообщение отправлено')
logger.warning('Большая нагрузка!')
logger.error('Бот не смог отправить сообщение')
logger.critical('Всё упало! Зовите админа!1!111') 
```

Глобальные настройки форматирования при этом не будут применены:

![image](https://pictures.s3.yandex.net/resources/S8_29_1632740690.png)

Для форматирования сообщений логгера нужно создать **форматер** и применить его к хэндлеру:

Скопировать кодPYTHON

```
...

# Создаем форматер
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Применяем его к хэндлеру
handler.setFormatter(formatter)

... 
```

Настройки форматирования будут применены к сообщениям логгера:

![image](https://pictures.s3.yandex.net/resources/S8_30_1632740830.png)

### Хэндлер

Хэндлер (англ. _Handler_) — это обработчик логов, переданных в логгер. В листинге применён обработчик **RotatingFileHandler**, он управляет ротацией логов.

Скопировать кодPYTHON

```
...

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
handler = RotatingFileHandler('my_logger.log', maxBytes=50000000, backupCount=5)
logger.addHandler(handler) 
```

**RotatingFileHandler** следит за объёмом и количеством лог-файлов. Файлы с логами со временем растут, занимают всё больше места и, в результате, могут забить всё дисковое пространство. Чтобы контролировать их объём, можно выставить ограничения количество этих файлов и на их размер.

Когда размер первого файла достигнет установленного предела — будет создан следующий файл (имя нового файла будет сформировано добавлением цифр в конце имени), а когда количество файлов дойдёт до заданного количества — начнёт перезаписываться самый первый файл. Этот круговорот и называется **ротацией логов**.

В параметрах RotatingFileHandler указывается максимальный размер одного лог-файла, путь и имя файлов, их предельное количество.

Модуль logging предоставляет довольно много стандартных обработчиков. Кроме RotatingFileHandler есть и другие, не менее популярные — **FileHandler**, который отправляет записи в файл, и **StreamHandler**, который отправляет записи в стандартные потоки, такие как [sys.stdout](https://docs.python.org/3/library/sys.html#sys.stdout) или [sys.stderr.](https://docs.python.org/3/library/sys.html#sys.stderr)

Если обработчики для логгера не определены — все записи будут отправляться в терминал.

### Логирование исключений

Исключения тоже можно логировать, но делать это нужно не всегда. Тут нет какого-то готового правила, разработчик обычно сам решает, какие исключения логировать, а какие нет.

Самый простой способ логирования исключений:

Скопировать кодPYTHON

```
# example_for_log.py

try:
    42 / 0
except Exception as error:
    logging.error(error, exc_info=True)

# Будет записано в лог:
# ERROR:root:division by zero
# Traceback (most recent call last):
#   File "/Users/stasbasov/dev/kittybot/example_for_log.py", line 4, in <module>
#     42 / 0
# ZeroDivisionError: division by zero 
```

Без параметра `exc_info` в лог запишется только текст исключения:

Скопировать кодPYTHON

```
# example_for_log.py

try:
    42 / 0
except Exception as error:
    logging.error(error)

# Будет записано в лог: ERROR:root:division by zero 
```

Существует более компактная запись, с помощью метода `logging.exception()`:

Скопировать кодPYTHON

```
# example_for_log.py

try:
    42 / 0
except Exception:
    logging.exception('На ноль делить нельзя!')

# Будет записано в лог:
# ERROR:root:На ноль делить нельзя!
# Traceback (most recent call last):
#   File "/Users/stasbasov/dev/kittybot/example_for_log.py", line 4, in <module>
#     42 / 0
# ZeroDivisionError: division by zero 
```

Перехватывать все исключения сразу — плохая практика. При таком подходе можно и не узнать о проблемах, потому что программа продолжит выполняться.

Однако такой вариант возможен в некоторых случаях: например, когда вы пишете чат-бота и важно, чтобы он не падал, когда какой-то из запросов не выполнится.

### Логирование в KittyBot

Подключим логирование к боту, это позволит в любой момент определить, почему что-то работает не так, как ожидалось. Данные будем выводить в терминал.

Скопировать кодPYTHON

```
# kittybot/kittybot.py

import logging
import os

import requests

from telegram import ReplyKeyboardMarkup
from telegram.ext import CommandHandler, Updater

from dotenv import load_dotenv 

load_dotenv()

secret_token = os.getenv('TOKEN')

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO)


URL = 'https://api.thecatapi.com/v1/images/search'


def get_new_image():
    try:
        response = requests.get(URL)
    except Exception as error:
        # Печатать информацию в консоль теперь не нужно:
        # всё необходимое будет в логах
        # print(error)
        logging.error(f'Ошибка при запросе к основному API: {error}')
        new_url = 'https://api.thedogapi.com/v1/images/search'
        response = requests.get(new_url)

    response = response.json()
    random_cat = response[0].get('url')
    return random_cat


def new_cat(update, context):
    chat = update.effective_chat
    context.bot.send_photo(chat.id, get_new_image())


def wake_up(update, context):
    chat = update.effective_chat
    name = update.message.chat.first_name
    button = ReplyKeyboardMarkup([['/newcat']], resize_keyboard=True)

    context.bot.send_message(
        chat_id=chat.id,
        text='Привет, {}. Посмотри какого котика я тебе нашел'.format(name),
        reply_markup=button
    )

    context.bot.send_photo(chat.id, get_new_image())


def main():
    updater = Updater(token=secret_token)

    updater.dispatcher.add_handler(CommandHandler('start', wake_up))
    updater.dispatcher.add_handler(CommandHandler('newcat', new_cat))

    updater.start_polling()
    updater.idle()


if __name__ == '__main__':
    main() 
```

### Охота на багов

— Что в логах? — спрашивает тимлид.

Стас почесал в затылке.

— В какие-то периоды перестают приходить ответы от _thecatapi.com_, это длится ровно три минуты, а потом снова всё начинает работать. Потом снова три минуты ответов нет — и опять всё восстанавливается... вот, опять: прямо сейчас ответы не приходят!

— Погоди, Стас. Я сделаю прямой запрос к _thecatapi.com_ из браузера. А ты сделай такой же запрос с телефона, только wi-fi отключи: проверим доступ через мобильного провайдера.

Через компьютер, подключенный к офисной сети, запрос не прошёл. А запрос с мобильника сработал.

— Что, это мой код так странно себя ведёт? — огорчённо спросил Стас.

— Нет, код в полном порядке.

Стас выдохнул.

— Похоже, система безопасности на нашем сервере увидела, что какая-то программа (а это твой бот!) слишком часто отправляет запросы к одному и тому же адресу. В результате включилась защита: система на три минуты блокирует запросы к этому адресу, а потом вновь их разрешает — система умная, она что-то там проверяет. Сейчас добавим адрес _thecatapi.com_ в список разрешённых — и всё заработает ровненько.

— Ну ничего себе... Без логов мы бы это не отловили! И что, часто такое происходит?

— Происходит часто, но всегда разное. Так что не забывай о логах: это экономит время и нервы.

### Нет предела совершенству

Пока Стас выслеживал багов, ему на почту упало ещё несколько правок к боту: написать докстринги, написать README, проверить форматирование — окончательно привести проект в товарный вид.

«Сделаю!», написал Стас в ответ.

«...попозже; завтра, например», добавил он про себя: на сегодня у Стаса уже были планы.

Во-первых, Стас нашёл в Telegram несколько интересных ботов и планировал рассмотреть их повнимательнее, чтобы разобраться, как они устроены.

А во-вторых, его приятелю, который учится программированию, задали самостоятельную работу — написать бота, который извещал бы студента о результатах проверки его домашнего задания; приятель попросил консультации. Как было отказать.