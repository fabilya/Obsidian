### Декоратор @api_view
Для «настройки» view-функции на работу с API в Django REST framework есть декоратор **@api_view**. В качестве аргумента декоратору передают список типов HTTP-запросов, которые должна обрабатывать эта функция:

```
@api_view([<разрешённые типы HTTP-запросов>])
def hello(request):
... 
```

Ещё одно отличие view-функции API в Django REST framework состоит в том, что они возвращают специальный объект класса **Response**; в этот объект в качестве аргумента передаётся Python-словарь, данные из которого и должны быть отправлены в ответ на запрос в JSON формате.

### Разделение обязанностей между view-функциями API

Классический API для целевой модели — это, как правило, реализация шести операций:

-   создание нового объекта;
-   получение информации об объекте;
-   удаление объекта;
-   замещение объекта (целиком);
-   изменение одного или нескольких полей объекта;
-   получение списка объектов.

Хорошая практика — сгруппировать эти операции в две view-функции.

Первая view-функция добавляет новые объекты в коллекцию или возвращает все объекты коллекции, например:

-   POST-запрос на адрес `cats/` создаст новую запись о котике;
-   GET-запрос на тот же адрес вернёт список всех котиков.

Вторая view-функция обрабатывает запросы для получения, изменения (полного или частичного) и удаления одиночного объекта:

-   GET-запрос к адресу `cats/<pk>/` вернёт информацию о конкретном котике по его id;
-   запросы PUT, PATCH или DELETE к тому же адресу перезапишут, изменят или удалят существующую запись о котике.

В результате для всех шести действий в _urls.py_ потребуется описать лишь два эндпоинта:

-   `cats/`,
-   `cats/<int:pk>/`.
    
    А ссылаться эти эндпоинты будут на две view-функции во _views.py_, например:
    
-   `cat_list()`,
-   `cat_detail()`.
LINKS:
[STATUS CODES](https://www.django-rest-framework.org/api-guide/status-codes/)