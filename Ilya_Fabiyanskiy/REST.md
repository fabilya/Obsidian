# API First. Архитектура REST

## API сервисы раньше и сейчас

Давным-давно, когда компьютеры были большие, а мониторы — маленькие, в интернет выходили с настольного компьютера, а единственным пользовательским клиентом был веб-браузер. Сайты работали по стандартной системе: сервер получал запрос и отдавал клиенту готовые HTML-страницы.

В современном мире у такого подхода есть два недостатка:

-   HTML-код нужен лишь браузеру. Например, мобильное приложение вполне обойдётся без HTML-форматирования, ему нужны лишь структурированные данные; мобильное приложение само позаботится об отображении полученных данных.
-   Поскольку HTML-код генерируется на сервере, при переходе от страницы к странице браузер перезагружает сайт целиком. Это неэффективно: приходится перерисовывать одинаковые элементы: шапку, меню, подвал. Разумнее получить данные об изменяющихся частях сайта и отрисовать только их.

Размышляя об этих проблемах, Тим Бернерс-Ли (его называют создателем интернета) и Рой Филдинг (его коллега) придумали принципы, которые позволяли бы масштабировать развитие всемирной сети.

Основная идея в том, что сервер возвращает только запрошенные данные, а клиент сам разбирается, как эти данные отобразить. Мобильное приложение будет использовать свои методы отрисовки, браузер или чат-бот — свои. В результате можно ограничиться одним API для разных платформ.

Такой подход получил название **API First**, то есть **сначала данные, а затем — интерфейсы для их отображения**.

Так появился **REST**.

## REST

_**RE**presentational **S**tate **T**ransfer,_ **REST** (англ. «передача состояния представления») — это набор принципов, которых следует придерживаться при создании API. Если API сделан по этим принципам, его называют **RESTful API** (или просто **REST API**).

![image](https://pictures.s3.yandex.net/resources/Untitled_1626422541.png)

Эти принципы стандартизируют передачу данных по сети; они похожи на правила вежливости, когда людям (серверам) удобно находиться в одном обществе (интернете) и понимать друг друга. И хотя за нарушение этих правил никого не накажут — всем становится лучше, если эти правила соблюдаются.

## Принципы REST

Эти принципы ввёл Рой Филдинг в 2000 году в своей [диссертации](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm) «Архитектурные стили и дизайн сетевых программных структур».

### 1. Клиент-сервер. Разделение ответственности между клиентом и сервером

Клиент и сервер отвечают за разные вещи. Ответственность клиента — пользовательский интерфейс, ответственность сервера — данные. Если API возвращает HTML-страницу, его нельзя назвать REST API: ведь при этом сервер берёт на себя ответственность за интерфейс.

### 2. Отсутствие состояния. Сервер не хранит состояние

Каждый запрос должен быть независимым, как будто он сделан в первый раз. Сервер не должен хранить какой-либо информации о клиенте. Каждый запрос клиента к серверу должен содержать всю информацию, необходимую для обработки этого запроса: кто запрашивает данные, какие данные запрашиваются.

### 3. Единый интерфейс

Интерфейс обращения к серверу одинаков для всех и не зависит от клиента. Запрос к данным может быть сформирован из браузера, мобильного приложения и с «умного» чайника по одним и тем же правилам.

### 4. Многоуровневость

Первый принцип гласит, что в коммуникации участвуют двое: клиент и сервер. Но можно строить более сложные системы, не нарушая этого принципа.

API сервиса Яндекс.Такси может использовать API Яндекс.Навигатора. Вы как клиент взаимодействуете только с API Яндекс.Такси, а он, в свою очередь, является клиентом навигатора. Здесь есть одно условие — каждый компонент должен видеть только свой уровень. Например, Яндекс.Навигатор не должен видеть все данные, которые вы отправили в Яндекс.Такси.

### 5. Кешируемость

Данные ответа могут быть закешированы. Это значит, что можно сохранить полученные данные на клиенте, а при идентичном запросе взять их из памяти клиента — кеша, а не ждать их с сервера. Нет смысла запрашивать данные повторно, если они никак не изменились.

### 6. Код по запросу

Этот принцип необязательный. Он гласит, что функциональность клиента может быть расширена кодом, приходящим с сервера. Сейчас такое можно встретить повсеместно: JavaScript используется для «оживления» страниц и исполнения каких-то сценариев на стороне клиента. Но принципы формулировались в 2000 году — тогда исполняемый код с сервера возвращали не так часто. Потому и выделили это в отдельный принцип.

# REST: ресурсы, эндпоинты и HTTP-методы

В базе данных проекта может храниться множество разнородной информации, и задача API — обеспечить доступ к этой информации.

Ключевая абстракция в REST это **ресурс**. Любая информация, которая может быть названа, может быть ресурсом: пост в социальной сети, коллекция постов, подборка актуальных новостей, пользователь сайта, коллекция любых объектов или других ресурсов.

Унифицированный указатель **ресурса**, или URL (от англ. _Uniform Resource Locator_), используют для указания, где находится тот или иной ресурс.

Скопировать код

```
/users              # Ресурсом может быть коллекция сущностей

/users/12           # Пользователь c id = 12 — это тоже ресурс

/latest-news        # Ресурс не обязательно должен быть статическим: 
                    # новости каждый день разные, но ресурс — один, постоянный

/users/12/playlists # Все плейлисты пользователя с id=12 — это ресурс, 
                    # содержащий коллекцию ресурсов 
```

В терминах REST URL-адрес, идентифицирующий ресурс, принято называть **эндпоинтом** (англ. endpoint, «конечная точка»).

# Правила именования ресурсов

Для обращения к ресурсам через HTTP-запросы их необходимо как-то именовать. Чем понятнее имена ресурсов, тем проще разобраться в API. Здорово, когда по названию ресурса можно понять, что именно он содержит.

Чтобы с вашим API было просто и удобно общаться — соблюдайте простые правила.

### Ресурсы — существительные

Почти всегда ресурсы именуют существительными во множественном числе:

Скопировать код

```
/users 
```

Скопировать код

```
/api/starships 
```

Перед вами API «Звёздных войн». Попробуйте догадаться, какой список объектов вернёт GET-запрос на [https://swapi.dev/api/starships](https://swapi.dev/api/starships)?

Правильный ответ

Список космических кораблей

Верно, стоит просто прочитать название ресурса.

Список планет

Список межпланетных барашков

1 из 3 правильно и 0 неправильно

Иногда для именования ресурсов применяют существительные в единственном числе:

Скопировать код

```
/users/{user-id}/profile
/users/me 
```

Иногда можно выбрать глагол в качестве имени. Но такое имя бывает удачным крайне редко:

Скопировать код

```
/users/{user-id}/cart/checkout  # Проверка корзины
/refresh  # Обновления токена 
```

### Слеш для иерархии

Слеш в URL используется для указания иерархии ресурсов по принципу «от общего к частному»:

Скопировать код

```
/users/{user-id}/posts 
```

_Все пользователи → Конкретный пользователь по ID → Все его посты_

А чтобы обратиться к конкретному посту, нужно указать его ID:

Скопировать код

```
/users/{user-id}/posts/{post-id} 
```

_Все пользователи → Конкретный пользователь по ID → Все его посты → Конкретный пост по ID_

### «Висячий» слеш

В разных API встречаются два способа описания URL ресурсов:

Скопировать код

```
# Первый вариант
/users/{user-id}/posts/  # Слеш в конце URL

# Второй вариант
/users/{user-id}/posts  # Нет слеша в конце URL 
```

Бытует мнение, что лучше избегать такого «висячего» слеша в конце URL — ведь он не добавляет информации.

Другое мнение заключается в том, что висячий слеш обязателен для любого ресурса, который может содержать дочерние элементы.

В REST нет однозначных рекомендаций, какой из подходов предпочтительнее. Придерживайтесь документации тех API, с которыми будете работать.

### Дефисы вместо пробелов

В URL не должно быть пробелов, их заменяют дефисами или подчёркиваниями. Лучше применять дефисы:

-   на некоторых устройствах подчёркивание может выйти за базовую линию строки, и его будет не видно вовсе;
-   несколько подчёркиваний сливаются в одно.

Скопировать код

```
# Делайте так:
/users/{user-id}/user-devices

# а не так:
/users/{user-id}/user_devices 
```

## [[HTTP-методы]]

